import { writeFile } from "../services/FileService";
import { recurseFileNodeList, recurseObject, recursionMaximumCheck } from "../services/RecursiveService";
import { Conditional } from "../types/fileParsing/Conditional";
import { FileNode, fileNodeTypeGuard } from "../types/fileParsing/FileNode";
import { CalledFunction } from "../types/fileParsing/function/CalledFunction";
import { DefinedFunction } from "../types/fileParsing/function/DefinedFunction";
import { Function } from "../types/fileParsing/function/Function";
import { Ident } from "../types/fileParsing/Ident";
import { DefinedVariable } from "../types/fileParsing/variable/DefinedVariable";
import { Variable } from "../types/fileParsing/variable/Variable";
import { Result } from "../types/results/Result";
import { TreeNode } from "../types/TreeNode";
import { VulnerabilityConfig } from "../types/vulnerabilityTypes/VulnerabilityConfig";
import { getVulnerabilityConfigurationList }  from "./VulnerabilityConfig";

//Future development - Take in and scan for multiple vulnerabilities
export function prepVulnerabilityData(): string {
    let vulnData:VulnerabilityConfig[] = getVulnerabilityConfigurationList();
    return "INCOMPLETE";
}

export function scan(scanObjects:FileNode[][]): Result[] {
    console.log("BEGINNING RECURSION SEQUENCE")

    let mappingList:TreeNode<FileNode>[] = [];

    for(let i:number = 0; i < scanObjects.length; i++) {
        console.log(scanObjects[i])
        let eventNode = new Ident("event","Identifier");
        let mapping:TreeNode<FileNode> = new TreeNode<FileNode>(eventNode.name,eventNode);
        mapping.parent = null as any;
        createSubMap(mapping, scanObjects[i], 0);
        mappingList.push(mapping)
    }
    console.log("MAPPINGLIST")
    console.log(mappingList);
    writeFile("./build/eventMappingList.json",mappingList);

    let compiledMapping:TreeNode<FileNode> = compileMappings(mappingList);
    writeFile("./build/eventMappingFinal.json",compiledMapping);

    let IDORList:FileNode[] = checkForIDOR(compiledMapping, 0);
    let resultList:Result[] = [];
    IDORList.forEach((el) => resultList.push(new Result(el,"IDOR")))
    
    return resultList;
}

function createSubMap(mapping:TreeNode<FileNode>, scanObject:FileNode[], recursions:number):TreeNode<FileNode> {
    if (recursionMaximumCheck(recursions)){
        throw new Error("Recursion has reached maximum depth.");
    }

    if (mapping.children.length === 0) {
        findEventChildren(mapping,scanObject);
    }

    if(mapping.children && mapping.children.length > 0) {
        mapping.children.map((child:TreeNode<FileNode>) => {
            return createSubMap(child,scanObject,recursions + 1);
        });
    }

    return mapping;
}

function findEventChildren(mapping:TreeNode<FileNode>, scanObject:FileNode[]):TreeNode<FileNode> {

    recurseFileNodeList(scanObject, 
        function(node:FileNode):boolean {
            return returnCriteriaForMapping(mapping, node);
        },
        function(node:FileNode):FileNode {
            mapping.children.push(new TreeNode(node.name,node));
            mapping.children.map((c) => c.parent = mapping.value)
            return null as any;
        },
        0)
    return mapping;
}

function returnCriteriaForMapping(mapping:TreeNode<FileNode>, obj:FileNode):boolean {
    /*
    Object is a parameter or initialization of mapping value
    Object is not an Identity parameter (too low level)
    Object is not the handler node
    Object is not itself or parent (no loops)
    */

    let functionTest:boolean = obj instanceof CalledFunction ? (obj as CalledFunction).parameterNames!.some((a) => a.some((b) => b ? b.name === mapping.name : false)) : false;
    let variableTest:boolean = obj instanceof DefinedVariable ? (obj as DefinedVariable).init!.some((a) => a.some((b) => b ? b.name === mapping.name :false )) : false;
    let conditionalTest:boolean = obj instanceof Conditional ? (obj as Conditional).args.some((a) => a.some((b) => b ? b.name === mapping.name :false )) : false;
    
    return (functionTest || variableTest || conditionalTest) &&
    obj.name !== "handler" && !(obj instanceof Ident) && 
    obj !== mapping.value && obj !== mapping.parent;
}

function compileMappings(mappingList:TreeNode<FileNode>[]):TreeNode<FileNode> {

    let returnMapping:TreeNode<FileNode>;

    if (mappingList.length === 1){
        returnMapping = mappingList[0];
    } else {

        returnMapping = mappingList[0];
        let subList:TreeNode<FileNode>[] = mappingList.slice(1);
        for(let i:number = 0; i < subList.length; i++){
            returnMapping.children.forEach((child:TreeNode<FileNode>) =>{
                compileMappingHelper(child,subList[i],0);
            });
        }
    }

    return returnMapping;
}

function compileMappingHelper(baseMapping:TreeNode<FileNode>, insertMapping:TreeNode<FileNode>, recursions:number):void {

    if(recursionMaximumCheck(recursions)){
        throw new Error("Recursion has reached maximum depth for Compile Mappings Helper.");
    }

    if(baseMapping.name === insertMapping.name && baseMapping.value.type === insertMapping.value.type) {
        insertMapping.children.forEach((c) => {
            baseMapping.children.push(c)
        })
        insertMapping.children = [];
    }

    if (!baseMapping.children || baseMapping.children.length === 0) {
        return;
    } else {
        insertMapping.children.map((child:TreeNode<FileNode>) =>{
            compileMappingHelper(baseMapping,child,recursions + 1);
        });
        baseMapping.children.map((child:TreeNode<FileNode>) =>{
            compileMappingHelper(child,insertMapping,recursions + 1);
        });
    }
    
}

function checkForIDOR(mapping:TreeNode<FileNode>, recursions:number): FileNode[] {

    if (recursionMaximumCheck(recursions)){
        throw new Error("Recursion has reached maximum depth.");
    }

    if(mapping.children.length === 0) {
        return [mapping.value];
    }

    if(returnCriteriaForIDORCheck(mapping)) {
        return [];
    } else {
        let returnable:FileNode[] = [];
        mapping.children.map((c) => (checkForIDOR(c,recursions+1)).map((result) => {
            if(result instanceof Conditional && mapping.value instanceof Variable){
                result = mapping.value;
            }
            if(result instanceof CalledFunction && mapping.value instanceof Variable) {
                returnable.push(result);
                result = mapping.value;
            }
            returnable.push(result);
        }));
        return returnable;
    }
}

function returnCriteriaForIDORCheck(mapping:TreeNode<FileNode>):boolean {
    let conditionalTest:boolean = mapping.value instanceof Conditional ?
    (mapping.value as Conditional).comparisonOperators?.length > 0 : false;
    return conditionalTest;
}

function mapToArray(mapping:TreeNode<FileNode>): FileNode[] {
    let returnable:FileNode[] = [mapping.value];
    mapping.children.map((node:TreeNode<FileNode>) =>{
        returnable.concat(mapToArray(node));
    });
    return returnable;
}