import { recurseFileNodeList, recurseObject, recursionMaximumCheck } from "../services/RecursiveService";
import { Conditional } from "../types/fileParsing/Conditional";
import { FileNode, fileNodeTypeGuard } from "../types/fileParsing/FileNode";
import { CalledFunction } from "../types/fileParsing/function/CalledFunction";
import { DefinedFunction } from "../types/fileParsing/function/DefinedFunction";
import { Function } from "../types/fileParsing/function/Function";
import { Ident } from "../types/fileParsing/Ident";
import { DefinedVariable } from "../types/fileParsing/variable/DefinedVariable";
import { Variable } from "../types/fileParsing/variable/Variable";
import { TreeNode } from "../types/TreeNode";
import { VulnerabilityConfig } from "../types/vulnerabilityTypes/VulnerabilityConfig";
import { getVulnerabilityConfigurationList }  from "./VulnerabilityConfig";

//Future development - Take in and scan for multiple vulnerabilities
export function prepVulnerabilityData(): string {
    let vulnData:VulnerabilityConfig[] = getVulnerabilityConfigurationList();
    return "INCOMPLETE";
}

export function scan(scanObject:FileNode[]): boolean {

    let eventNode:FileNode = findEvent(scanObject);

    console.log("BEGINNING RECURSION SEQUENCE")

    let mapping:TreeNode<FileNode> = new TreeNode<FileNode>(eventNode.name,eventNode);
    mapping.parent = null as any;
    createSubMap(mapping, scanObject, 0);

    var fs = require('fs');
    fs.writeFile ("./build/eventMapping.json", JSON.stringify(mapping), function(err:any) {
        if (err) throw err;
            console.log('mapping complete');
        }
    );

    let IDORList:FileNode[] = checkForIDOR(mapping, 0);

    console.log();
    console.log("----------------------------------------");
    for(let i:number = 0; i < IDORList.length; i++) {
        if(IDORList[i] instanceof Variable) {
            console.log("IDOR may exist on variable: ");
            console.log(IDORList[i]);
        }
        if(IDORList[i] instanceof CalledFunction) {
            console.log("Function calling potentially vulnerable variable:");
            console.log(IDORList[i]);
        }
        console.log();
    }
    console.log("----------------------------------------");
    return true;
}

function findEvent(scanObject:FileNode[]): FileNode {

    for(let i:number = 0; i < scanObject.length; i++) {
        if(scanObject[i] instanceof DefinedFunction){
            let node:DefinedFunction = scanObject[i];
            // exports.handler = ...
            if(node.name === "handler" && node.super?.some((a:any) => a.name === 'exports')){
                if(node.parameterNames) return node.parameterNames[0][0];
            }
        }
    }

    console.log("Unable to locate handler.")
    return null as any;
}

function createSubMap(mapping:TreeNode<FileNode>, scanObject:FileNode[], recursions:number):TreeNode<FileNode> {
    if (recursionMaximumCheck(recursions)){
        throw new Error("Recursion has reached maximum depth.");
    }

    if (mapping.children.length === 0) {
        findEventChildren(mapping,scanObject);
    }

    if(mapping.children && mapping.children.length > 0) {
        mapping.children.map((child:TreeNode<FileNode>) => {
            return createSubMap(child,scanObject,recursions + 1);
        });
    }

    return mapping;
}

function findEventChildren(mapping:TreeNode<FileNode>, scanObject:FileNode[]):TreeNode<FileNode> {

    recurseFileNodeList(scanObject, 
        function(node:FileNode):boolean {
            return returnCriteriaForMapping(mapping, node);
        },
        function(node:FileNode):FileNode {
            mapping.children.push(new TreeNode(node.name,node));
            mapping.children.map((c) => c.parent = mapping.value)
            return null as any;
        },
        0)
    return mapping;
}

function returnCriteriaForMapping(mapping:TreeNode<FileNode>, obj:FileNode):boolean {
    /*
    Object is a parameter or initialization of mapping value
    Object is not an Identity parameter (too low level)
    Object is not the handler node
    Object is not itself or parent (no loops)
    */

    let functionTest:boolean = obj instanceof CalledFunction ? (obj as CalledFunction).parameterNames!.some((a) => a.some((b) => b ? b.name === mapping.name : false)) : false;
    let variableTest:boolean = obj instanceof DefinedVariable ? (obj as DefinedVariable).init!.some((a) => a.some((b) => b ? b.name === mapping.name :false )) : false;
    let conditionalTest:boolean = obj instanceof Conditional ? (obj as Conditional).args.some((a) => a.some((b) => b ? b.name === mapping.name :false )) : false;
    
    return (functionTest || variableTest || conditionalTest) &&
    obj.name !== "handler" && !(obj instanceof Ident) && 
    obj !== mapping.value && obj !== mapping.parent;
}

function checkForIDOR(mapping:TreeNode<FileNode>, recursions:number): FileNode[] {

    if (recursionMaximumCheck(recursions)){
        throw new Error("Recursion has reached maximum depth.");
    }

    if(mapping.children.length === 0) {
        return [mapping.value];
    }

    if(returnCriteriaForIDORCheck(mapping)) {
        return [];
    } else {
        let returnable:FileNode[] = [];
        mapping.children.map((c) => (checkForIDOR(c,recursions+1)).map((result) => {
            if(result instanceof Conditional && mapping.value instanceof Variable){
                result = mapping.value;
            }
            if(result instanceof CalledFunction && mapping.value instanceof Variable) {
                returnable.push(result);
                result = mapping.value;
            }
            returnable.push(result);
        }));
        return returnable;
    }
}

function returnCriteriaForIDORCheck(mapping:TreeNode<FileNode>):boolean {
    let conditionalTest:boolean = mapping.value instanceof Conditional ?
    (mapping.value as Conditional).comparisonOperators?.length > 0 : false;

    return conditionalTest;
}

function mapToArray(mapping:TreeNode<FileNode>): FileNode[] {
    let returnable:FileNode[] = [mapping.value];
    mapping.children.map((node:TreeNode<FileNode>) =>{
        returnable.concat(mapToArray(node));
    });
    return returnable;
}